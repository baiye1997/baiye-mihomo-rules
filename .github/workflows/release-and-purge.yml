name: Release and Purge CDN

on:
  push:
    paths:
      - "rules/ip/**"
      - "rules/non_ip/**"
      - "rules/domainset/**"
      - "rules/yaml/**"
      - "icons/**"
      - "config/*.yaml"
      - "config/*.yml"
  workflow_dispatch:
    inputs:
      force_bump_icons:
        description: "即使没有 icons 变更，也为 config 里的 icon URL 追加 ?v"
        type: boolean
        default: false
      force_purge:
        description: "即使没有匹配到目标文件，也执行全量 purge（icons + rules + config）"
        type: boolean
        default: false

concurrency:
  group: release-and-purge
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  release_purge:
    runs-on: ubuntu-latest
    env:
      FORCE_BUMP_ICONS: ${{ inputs.force_bump_icons && 'true' || 'false' }}
      FORCE_PURGE: ${{ inputs.force_purge && 'true' || 'false' }}
    steps:
      - name: Show trigger info
        if: always()
        run: |
          echo "Head: ${{ github.sha }}"
          echo "Ref:  ${{ github.ref }}"
          echo "Event: ${{ github.event_name }}"
          echo "FORCE_BUMP_ICONS=${FORCE_BUMP_ICONS}"
          echo "FORCE_PURGE=${FORCE_PURGE}"

      - name: Debounce wait
        run: sleep 30

      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Self-skip if last commit is icon bump
        id: selfskip
        shell: bash
        run: |
          LASTMSG="$(git log -1 --pretty=%s)"
          echo "Last commit message: $LASTMSG"
          if echo "$LASTMSG" | grep -qE '^chore\(ci\): bump icon cache-buster \?v='; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Decision: self-skip = true"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Decision: self-skip = false"
          fi

      - name: Detect changed files (targets & flags)
        if: steps.selfskip.outputs.skip == 'false'
        id: chg
        shell: bash
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          if [ -z "${BEFORE}" ]; then BEFORE="$(git rev-parse HEAD^ || echo '')"; fi

          if [ -n "${BEFORE}" ]; then
            git diff --name-only "${BEFORE}" "${{ github.sha }}" > changed.all.txt
          else
            git show --name-only --pretty="" "${{ github.sha }}" > changed.all.txt
          fi

          grep -E '^(icons/|rules/(ip|non_ip|domainset|yaml)/)' changed.all.txt | sort -u > changed.targets.txt || true

          # 变更/强制 标记
          ICONS_CHANGED=false
          CONFIG_CHANGED=false
          HAS_TARGETS=false
          grep -qE '^icons/' changed.all.txt && ICONS_CHANGED=true
          grep -qE '^config/.*\.ya?ml$' changed.all.txt && CONFIG_CHANGED=true
          [ -s changed.targets.txt ] && HAS_TARGETS=true

          # 接受手动强制
          if [ "${FORCE_BUMP_ICONS}" = "true" ]; then ICONS_CHANGED=true; fi
          if [ "${FORCE_PURGE}" = "true" ]; then HAS_TARGETS=true; fi

          echo "icons_changed=${ICONS_CHANGED}"   >> $GITHUB_OUTPUT
          echo "config_changed=${CONFIG_CHANGED}" >> $GITHUB_OUTPUT
          echo "has_targets=${HAS_TARGETS}"       >> $GITHUB_OUTPUT

          {
            echo "body<<EOF"
            echo "### Changed files"
            if [ -s changed.all.txt ]; then sed 's/^/- /' changed.all.txt; else echo "- (no file list available)"; fi
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "Changed targets:"; cat changed.targets.txt || true

      - name: Bump icon URLs in config (?v=<short>) on icons change (with logs)
        if: steps.selfskip.outputs.skip == 'false' && steps.chg.outputs.icons_changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          SHORT="$(git rev-parse --short=7 HEAD)"
          echo "SHORT for this run = $SHORT"

          # 预览替换前：列出 config 中的 icons URL
          echo "[preview-before] icons URLs in config:"
          grep -RnoE 'https?://[^"'"'"'<>[:space:]]+/icons/[^"'"'"'<>[:space:]]+\.(png|jpe?g|webp|svg)(\?[^"'"'"'<>[:space:]]*)?' config || true

          python - "$SHORT" <<'PY'
          import sys, re, pathlib, urllib.parse
          SHORT = sys.argv[1]

          url_pat = re.compile(r'https?://[^\s"\'<>]+')

          def is_icon_path(parsed):
              path = parsed.path or ""
              return re.search(r'/icons/[^/]+\.(?:png|jpe?g|webp|svg)$', path, re.I) is not None

          def bump_icon_url(u, short):
              try:
                  p = urllib.parse.urlsplit(u)
              except Exception:
                  return u, False
              if not is_icon_path(p):
                  return u, False
              q = urllib.parse.parse_qsl(p.query, keep_blank_values=True)
              q = [(k, v) for (k, v) in q if k.lower() != 'v']
              q.append(('v', short))
              new_q = urllib.parse.urlencode(q)
              new_u = urllib.parse.urlunsplit((p.scheme, p.netloc, p.path, new_q, p.fragment))
              return new_u, (new_u != u)

          # 计数用字典，避免 nonlocal 报错
          counters = {"hits": 0, "changed": 0}

          for path in pathlib.Path("config").rglob("*.yml*"):
              s = path.read_text(encoding="utf-8")
              changed_here = [0]  # 用列表包装成可变对象

              def repl(m, counters=counters, changed_here=changed_here):
                  counters["hits"] += 1
                  new, changed = bump_icon_url(m.group(0), SHORT)
                  if changed:
                      counters["changed"] += 1
                      changed_here[0] += 1
                  return new

              ns = url_pat.sub(repl, s)
              if ns != s:
                  path.write_text(ns, encoding="utf-8")
                  print(f"[icon-bump] changed {path} (+{changed_here[0]})")
              else:
                  print(f"[icon-bump] no change in {path}")

          print(f"[icon-bump] summary: url_hits={counters['hits']}, replacements={counters['changed']}")
          PY

          echo "[preview-after] icons URLs in config:"
          grep -RnoE 'https?://[^"'"'"'<>[:space:]]+/icons/[^"'"'"'<>[:space:]]+\.(png|jpe?g|webp|svg)(\?[^"'"'"'<>[:space:]]*)?' config || true

          if ! git diff --quiet; then
            echo "[git] diff detected, committing..."
            git config user.name  "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "chore(ci): bump icon cache-buster ?v=${SHORT} [skip ci]"
            git push
          else
            echo "No icon URL changes in config."
          fi

      - name: Compute version tag (UTC + short HEAD)
        if: steps.selfskip.outputs.skip == 'false'
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          SHORT="$(git rev-parse --short=7 HEAD)"
          echo "tag=v$(date -u +%Y.%m.%d-%H%M)-${SHORT}" >> $GITHUB_OUTPUT

      - name: Create tag
        if: steps.selfskip.outputs.skip == 'false' && (steps.chg.outputs.has_targets == 'true' || steps.chg.outputs.config_changed == 'true')
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.ver.outputs.tag }}"
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "Tag $TAG already exists. Skipping."
          else
            git tag "$TAG"
            git push origin "$TAG"
          fi

      - name: Create GitHub Release
        if: steps.selfskip.outputs.skip == 'false' && (steps.chg.outputs.has_targets == 'true' || steps.chg.outputs.config_changed == 'true')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.tag }}
          name: ${{ steps.ver.outputs.tag }}
          body: ${{ steps.chg.outputs.body }}

      - name: Purge jsDelivr for changed rules/icons (@latest + @main)
        if: always() && steps.selfskip.outputs.skip == 'false' && steps.chg.outputs.has_targets == 'true'
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          # 如果是强制 purge，构造全量目标列表
          if [ "${FORCE_PURGE}" = "true" ]; then
            { git ls-files "icons/*" "rules/ip/**" "rules/non_ip/**" "rules/domainset/**" "rules/yaml/**" || true; } | sort -u > changed.targets.txt
          fi
          while read -r p; do
            [ -n "$p" ] || continue
            for REF in latest main; do
              URL="https://purge.jsdelivr.net/gh/${REPO}@${REF}/${p}"
              echo "Purging $URL"
              curl -fsS "$URL" >/dev/null || true
            done
          done < changed.targets.txt

      - name: Purge jsDelivr for subscription templates (@latest + @main)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          shopt -s nullglob
          for f in config/*.yaml config/*.yml; do
            for REF in latest main; do
              URL="https://purge.jsdelivr.net/gh/${REPO}@${REF}/${f}"
              echo "Purging $URL"
              curl -fsS "$URL" >/dev/null || true
            done
          done
