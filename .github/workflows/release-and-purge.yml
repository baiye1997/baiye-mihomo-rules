name: Release (@latest) & Purge CDN on rules/icons change

on:
  push:
    paths:
      - "rules/ip/**"
      - "rules/non_ip/**"
      - "rules/domainset/**"
      - "rules/yaml/**"
      - "icons/**"
  workflow_dispatch: {}

# 防重复并发（多次快速推送时只保留最新一次）
concurrency:
  group: release-and-purge
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  release_purge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute version tag (UTC + short SHA)
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          echo "TAG=v$(date -u +%Y.%m.%d-%H%M)-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Detect changed files (this push)
        id: chg
        shell: bash
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          # 某些触发（例如第一次提交）可能拿不到 before；回退到上一提交
          if [ -z "${BEFORE}" ]; then
            BEFORE="$(git rev-parse HEAD^ || echo '')"
          fi

          if [ -n "${BEFORE}" ]; then
            git diff --name-only "${BEFORE}" "${{ github.sha }}" > changed.all.txt
          else
            # 没有 before：退化为本次提交的文件列表
            git show --name-only --pretty="" "${{ github.sha }}" > changed.all.txt
          fi

          # 再保险过滤一遍（只保留真正分发的目录+icons）
          grep -E '^(icons/|rules/(ip|non_ip|domainset|yaml)/)' changed.all.txt | sort -u > changed.targets.txt || true

          if [ -s changed.targets.txt ]; then
            echo "HAS_TARGETS=true" >> $GITHUB_OUTPUT
          else
            echo "HAS_TARGETS=false" >> $GITHUB_OUTPUT
          fi

          {
            echo "BODY<<EOF"
            echo "### Changed files"
            if [ -s changed.all.txt ]; then
              sed 's/^/- /' changed.all.txt
            else
              echo "- (no file list available)"
            fi
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "Changed targets:"
          cat changed.targets.txt || true

      - name: Create tag (skip if exists or no targets)
        if: steps.chg.outputs.HAS_TARGETS == 'true'
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.ver.outputs.TAG }}"
          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "Tag $TAG already exists. Skipping tag creation."
          else
            git tag "$TAG"
            git push origin "$TAG"
          fi

      - name: Create GitHub Release
        if: steps.chg.outputs.HAS_TARGETS == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.TAG }}
          name: ${{ steps.ver.outputs.TAG }}
          body: ${{ steps.chg.outputs.BODY }}

      - name: Purge jsDelivr cache for changed files (@latest + @main)
        if: always() && steps.chg.outputs.HAS_TARGETS == 'true'
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          while read -r p; do
            [ -n "$p" ] || continue
            for REF in latest main; do
              URL="https://purge.jsdelivr.net/gh/${REPO}@${REF}/${p}"
              echo "Purging $URL"
              curl -fsS "$URL" >/dev/null || true
            done
          done < changed.targets.txt

      - name: Purge jsDelivr cache for subscription templates (@latest + @main)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          shopt -s nullglob
          for f in config/*.yaml config/*.yml; do
            for REF in latest main; do
              URL="https://purge.jsdelivr.net/gh/${REPO}@${REF}/${f}"
              echo "Purging $URL"
              curl -fsS "$URL" >/dev/null || true
            done
          done
