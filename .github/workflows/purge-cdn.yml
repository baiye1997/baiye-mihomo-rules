name: Purge CDN

on:
  push:
    branches: ['**']
    tags-ignore: ['**']
    paths:
      - "rules/ip/**"
      - "rules/non_ip/**"
      - "rules/domainset/**"
      - "rules/yaml/**"
      - "icons/**"
      - "config/*.yaml"
      - "config/*.yml"
  workflow_dispatch:
    inputs:
      force_purge:
        description: "Force purge all referenced targets"
        type: boolean
        required: false
        default: false

concurrency:
  group: purge-cdn
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  release_purge:
    if: ${{ github.event_name != 'push' || startsWith(github.ref, 'refs/heads/') }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # 需要 diff，所以深度至少为 2

      - name: Detect referenced targets
        id: detect
        shell: bash
        env:
          FORCE_PURGE: ${{ github.event_name == 'workflow_dispatch' && inputs.force_purge || 'false' }}
        run: |
          set -euo pipefail
          # --- 保持原有检测逻辑不变 ---
          CONFIGS=(config/*.yml config/*.yaml)
          : > referenced.targets.txt

          if [[ "${FORCE_PURGE}" == "true" ]]; then
            # ... 强制模式逻辑 (保持原样) ...
            if [ -d icons ]; then find icons -type f -print | sort -u >> all.txt; fi
            for d in rules/ip rules/non_ip rules/domainset rules/yaml; do [ -d "$d" ] && find "$d" -type f -print; done | sort -u >> all.txt || true
            while read -r P; do
              RP="${P#./}"
              if grep -RqlF -- "$RP" "${CONFIGS[@]}" || grep -RqlF -- "./$RP" "${CONFIGS[@]}"; then echo "$RP" >> referenced.targets.txt; fi
            done < all.txt
          else
            # ... Diff 模式逻辑 (保持原样) ...
            git diff --name-only HEAD~1 HEAD | sort -u > changed.all.txt
            grep -E '^(icons|rules/(ip|non_ip|domainset|yaml))/' changed.all.txt > changed.targets.txt || true
            if [ -s changed.targets.txt ]; then
              while read -r P; do
                if grep -RqlF -- "$P" "${CONFIGS[@]}" || grep -RqlF -- "./$P" "${CONFIGS[@]}"; then echo "$P" >> referenced.targets.txt; fi
              done < changed.targets.txt
            fi
          fi
          
          if [ -s referenced.targets.txt ]; then
            sort -u -o referenced.targets.txt referenced.targets.txt
            echo "has_ref=true" >> "$GITHUB_OUTPUT"
            # 打印摘要
            echo "Targets to purge:" >> $GITHUB_STEP_SUMMARY
            sed 's/^/- /' referenced.targets.txt >> $GITHUB_STEP_SUMMARY
          else
            echo "has_ref=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Purge jsDelivr @main (Concurrent)
        if: steps.detect.outputs.has_ref == 'true'
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          echo "Starting concurrent purge..."
          
          # 优化：使用 xargs -P 10 并发刷新
          cat referenced.targets.txt | \
          awk -v repo="$REPO" '{print "https://purge.jsdelivr.net/gh/" repo "@main/" $1}' | \
          xargs -P 10 -I {} bash -c '
            url="{}"
            if curl -fsS "$url" >/dev/null; then
              echo "✅ Purged: $url"
            else
              echo "❌ Failed: $url"
            fi
          '
