name: Purge CDN

on:
  push:
    branches: ['**']
    tags-ignore: ['**']     # 忽略 tag push
    paths:
      - "rules/ip/**"
      - "rules/non_ip/**"
      - "rules/domainset/**"
      - "rules/yaml/**"
      - "icons/**"
      - "config/*.yaml"
      - "config/*.yml"
  workflow_dispatch:
    inputs:
      force_purge:
        description: "Force purge all referenced targets (ignore diff)"
        type: boolean
        required: false
        default: false

concurrency:
  group: purge-cdn
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  release_purge:
    # 仅在分支 push 触发；确保不被 tag push 触发
    if: ${{ github.event_name != 'push' || startsWith(github.ref, 'refs/heads/') }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (with history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # tag 情况下仍强制检出 main（虽然上面的 if 已规避）
          ref: ${{ startsWith(github.ref, 'refs/tags/') && 'main' || github.ref }}

      # 侦测 icons/rules 在 config 中的“被引用目标”
      - name: Detect referenced targets (icons/rules) for purge
        id: detect
        shell: bash
        env:
          FORCE_PURGE: ${{ github.event_name == 'workflow_dispatch' && inputs.force_purge || 'false' }}
        run: |
          set -euo pipefail
          STEP_SUMMARY="${GITHUB_STEP_SUMMARY:-/dev/null}"

          echo "## Purge detect" >> "$STEP_SUMMARY"
          echo "" >> "$STEP_SUMMARY"

          shopt -s nullglob
          CONFIGS=(config/*.yml config/*.yaml)

          : > referenced.targets.txt

          if [[ "${FORCE_PURGE}" == "true" ]]; then
            echo "**Mode:** Force purge (ignore diff)" >> "$STEP_SUMMARY"
            echo "" >> "$STEP_SUMMARY"

            if [ ${#CONFIGS[@]} -eq 0 ]; then
              echo "_No config YAML files found. Nothing to purge._" >> "$STEP_SUMMARY"
              echo "has_ref=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # 1) 枚举仓库内所有候选文件
            : > all.candidates.txt
            if [ -d icons ]; then
              find icons -type f -print | sort -u >> all.candidates.txt
            fi
            for d in rules/ip rules/non_ip rules/domainset rules/yaml; do
              [ -d "$d" ] && find "$d" -type f -print
            done | sort -u >> all.candidates.txt || true

            # 2) 逐个判断是否在任一 config 被引用（兼容 ./ 前缀）
            while read -r P; do
              [ -n "$P" ] || continue
              RP="${P#./}"
              if grep -RqlF -- "$RP" "${CONFIGS[@]}" || grep -RqlF -- "./$RP" "${CONFIGS[@]}"; then
                echo "$RP" >> referenced.targets.txt
              fi
            done < all.candidates.txt
            rm -f all.candidates.txt

          else
            echo "**Mode:** Diff-based purge" >> "$STEP_SUMMARY"
            echo "" >> "$STEP_SUMMARY"

            AFTER="$(git rev-parse HEAD)"
            BEFORE="$(git rev-parse "${AFTER}^" 2>/dev/null || echo '')"

            : > changed.all.txt
            if [ -n "$BEFORE" ]; then
              git diff --name-only "$BEFORE" "$AFTER" | sort -u > changed.all.txt
            fi

            : > changed.targets.txt
            if [ -s changed.all.txt ]; then
              # 只保留关心范围（目录前缀精确过滤，无需复杂正则）
              awk '
                /^icons\// {print; next}
                /^rules\/ip\// {print; next}
                /^rules\/non_ip\// {print; next}
                /^rules\/domainset\// {print; next}
                /^rules\/yaml\// {print; next}
              ' changed.all.txt | sort -u > changed.targets.txt || true
            fi

            if [ -s changed.targets.txt ]; then
              echo "**Candidate targets (diff ${BEFORE:0:7}..${AFTER:0:7}):**" >> "$STEP_SUMMARY"
              sed 's/^/- /' changed.targets.txt >> "$STEP_SUMMARY"
              echo "" >> "$STEP_SUMMARY"
            else
              echo "_No candidate targets under icons/rules._" >> "$STEP_SUMMARY"
              echo "" >> "$STEP_SUMMARY"
            fi

            # 在配置文件中确认“被引用”的变更项（兼容 ./ 前缀）
            if [ ${#CONFIGS[@]} -gt 0 ] && [ -s changed.targets.txt ]; then
              while read -r P; do
                [ -n "$P" ] || continue
                if grep -RqlF -- "$P" "${CONFIGS[@]}" || grep -RqlF -- "./$P" "${CONFIGS[@]}"; then
                  echo "$P" >> referenced.targets.txt
                fi
              done < changed.targets.txt
            fi
          fi

          # 去重 + 仅保留实际存在的文件（避免 purge 404）
          if [ -s referenced.targets.txt ]; then
            sort -u -o referenced.targets.txt referenced.targets.txt
            awk '{ if ($0 !~ /\/$/ && system("[ -e \""$0"\" ]")==0) print $0 }' referenced.targets.txt > tmp && mv tmp referenced.targets.txt
          fi

          if [ -s referenced.targets.txt ]; then
            echo "**Referenced targets (will purge @main):**" >> "$STEP_SUMMARY"
            sed 's/^/- /' referenced.targets.txt >> "$STEP_SUMMARY"
            echo "has_ref=true" >> "$GITHUB_OUTPUT"
          else
            echo "_No referenced targets found (nothing to purge)._ " >> "$STEP_SUMMARY"
            echo "has_ref=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Purge jsDelivr @main
        if: steps.detect.outputs.has_ref == 'true'
        shell: bash
        run: |
          set -euo pipefail
          : > purged.txt
          REPO="${{ github.repository }}"
          # 可选限速，避免被风控：sleep 0.2
          while read -r p; do
            [ -n "$p" ] || continue
            url="https://purge.jsdelivr.net/gh/${REPO}@main/${p}"
            echo "Purging $url"
            if curl -fsS "$url" >/dev/null; then
              echo "$url" >> purged.txt
            fi
            # sleep 0.2
          done < referenced.targets.txt

      - name: Summarize purge result
        shell: bash
        run: |
          set -euo pipefail
          STEP_SUMMARY="${GITHUB_STEP_SUMMARY:-/dev/null}"
          echo "## Purge result" >> "$STEP_SUMMARY"
          if [ -s purged.txt ]; then
            echo "" >> "$STEP_SUMMARY"
            echo "**Purged URLs (@main):**" >> "$STEP_SUMMARY"
            sed 's/^/- /' purged.txt >> "$STEP_SUMMARY"
            echo "" >> "$STEP_SUMMARY"
            echo "> Total purged: $(wc -l < purged.txt)" >> "$STEP_SUMMARY"
          else
            echo "" >> "$STEP_SUMMARY"
            echo "Nothing to purge." >> "$STEP_SUMMARY"
          fi
